# memo

## In Progress
- 1/28
    - 入力
    - 出力
    - 実装0
- 1/29
    - テストスクリプト作成
- 1/31
    - solve1を実装した
- 2/2
    - コードを全修正(デバッグなし)
    - 繰り返しダイクストラ法を実装
- 2/3
    - デバッグ
    - 解法02に対して，繰り返しダイクストラ法を用いた更新
        - 全点ダイクストラ法は厳しい
- 2/5
    - 抽出点ダイクストラ法を利用し，solve1でスワップしていく方法(solve3)
    - しかし，スコアが上がらず．抽出がよくなかった？
    - 最終提出は各日の工事する数を平均値にして，同じ頂点で工事が被らない方法(solve1)



## input
- N: グラフの頂点数 500 <= N <= 1000
- M: グラフの辺の数 500 <= M <= 3000
- D: 日数           5 <= D <= 30
- K: 工事可能な上限 ceil(M/D) < K <= 2 x ceil(M/D)

## 考え
### スコア計算方法
- ワーシャルフロイド法で全点対距離は求められるが，計算量はV^3
    - 10^9
    - 厳しそう
- 繰り返しダイクストラ(計算量はV(E+V)logV)
    - 最大でも，10^3 * (3000 + 1000) * log1000 ~ 10^7
    - これならできそう
- 途中からはAスターアルゴリズムとかも使える？

### スコア計算に必要な関数
- 繰り返しダイクストラ: ダイクストラ + ループ
- 基準となる，どの辺も工事していない時の全点対距離を求める
- 工事する日程を受け取ってグラフを削除する
- そのグラフを対象に，全点対距離を求める


## solve0-1: シャッフル法
- 1日に工事する個数を決める
    - ある日程で工事する個数を増やすと，遠回りが増えたり，グラフが連結でなくなる可能性が高くなりそうだ．
    - どの日程も同じくらいになるようにしよう
    - M÷Kで求めて，足りない分は1ずつ割り振る．
- ID順に辺の工事する日程を決める
- 乱数でシャッフルする
- 166_826_989_691
- 186_218_449_681

## solve0-2: シャッフル法改
- 工事しない日程をたくさん作る
    - 最初の方の日程で工事できる上限まで入れる．
- 903_446_815_825

## solve1: 頂点個数制限方法
- 1日に工事する辺の数を選ぶ
    - solve0-1 or 0-2
- 頂点を順に探索して，そのうちランダムに道を一つ選ぶ
- 次の頂点を見る時，既に選ばれた道と繋がっている場合はスキップする
- 一周してまだ余裕があればもう一周する
- solve-11: 毎日平等に与える
    - 45_397_600_321
- 後半の方で偏っているので，頂点をランダムにする
- solve-12: 工事しない日程をたくさん作る
    - 559_344_478_522

- 頂点を絞ってスコア計算を行い，工事する2辺をスワップしてスコアが下がれば採用する
    - 工事する2辺の選び方
        - 日程は不満度が最も低い日と，最終日 or 不満度が最も高い日
        - 入れ替える辺の数は，0.1*M÷D

## solve2: 幹線道路探索法
- おそらく主要な頂点がある

## solve3: スコア計算法
- 愚直に繰り返しダイクストラ法で評価は厳しい
    - 一回の計算量が，N(N + M)logN ~ max: 10^7
    - 適当な頂点を10~50個くらい選べば推測できそうな気もする

## 用語
- 2-辺連結な平面グラフ
    - グラフは1本取り除いても必ず連結である

