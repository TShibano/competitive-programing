# Caphter1 アルゴリズムと計算量
## 1.0 アルゴリズムと計算量
- アルゴリズム: 問題を解くための「計算手順」のこと
    - 同じ問題でも複数のアルゴリズムが考えられ，効率の良し悪しが異なる
- 具体例1: 1, 2, ..., 50の計算
    - 1つず足していく
    - 51 * 25
- 具体例2: 迷路の最短手数
    - スタート地点から出発する経路を全部調べる
    - 幅優先探索
- 計算量: $O()$記号を用いて評価できる
    - 家庭用PCの計算速度は毎秒10億回(10^9)程度．
    - 計算量がこれを超える場合は考察し直すか，より良いデータ構造を用いる

## 1.1 導入問題
- まずは問題形式と入出力に慣れる
- A01: The First Problem
    - 1文字の入力
- B01: A+B Problem
    - 空白入り複数個の入力

## 1.2 全探索(1)
- 全探索
    - ありうる全てのパターンを調べ上げる方法
    - 原理的にはほとんどの問題を解決することができる(ただし計算量の問題がある)
- A02: Linear Search
    - 線形探索
- B02: Divisor Check

## 1.3 全探索(2)
- A03: Two Cards
    - 2重ループを回す．2重ループは計算量に注意する
- B03: Supermarket1
    - 3重ループを回す．
    - 多重ループは可能だが，ネストが深くなり可読性が落ちる．


## 1.4 2進法
- 10進数は，下の桁から順に1, 10, 100, ...の位になっている
- 2進数を10進数に変換する方法
    - 下の桁から順に1, 2, 4, ...の位となっていくので，数字x位の総和をとる
- 10進数を2進数に変換する方法
    - 1の位: N÷1の商を2で割ったあまり
    - 2の位: N÷2の商を2で割ったあまり
    - 4の位: N÷4の商を2で割ったあまり
    - 以下続く
- N進数と10進数の変換も同様に考えられる
- シフト演算
    - `x << n`: xをn桁左シフト．x * 2^n
    - `x >> n`: xをn桁右シフト．x / 2^n
- A04: Binary Representation1
    - 10進数 -> 2進数を計算する
- B04: Binary Representation2
    - 2進数 -> 10進数を計算する

## 1.5 チャレンジ問題
- A05: Three Cards
    - 単純にループを回すと計算が終わらない
    - 計算量を削減するために考察する
    - 2枚のカードが決まれば，残り一枚も必ず決まるという性質を用いる

## コラム1 ビット演算
- 論理演算
    - 0か1を取る値(ビット)の間で行われる演算
    - AND, OR, XORなど
- ビット演算
    - 2進数で表される値に対して行われる演算
    - AND, OR, XORは整数を2進数で表した時の各桁ごとの論理演算
    - 3個以上の値の演算は，順々にビット演算を適用すれば良い

## コラム2 ビット全探索
- 2進数を使って全探索する実装するテクニック
- 選ぶ選ばないをビットで表現することで全探索する
- N個のものから選ぶ選ばないは0 ~ 2^N-1 の整数で表現できる
